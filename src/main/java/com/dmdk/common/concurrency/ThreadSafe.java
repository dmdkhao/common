package com.dmdk.common.concurrency;

/**
 * 基础知识-线程安全性
 * 前言：
 *      要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享（Shared）和可变（Mutable）状态的访问。共享——可以多个线程同时访问；可变——变量的值在其生命周期内可以发生变化。
 *      对象的状态：存储在状态变量（例如实力或静态域）中的数据。可能也包括其他依赖对象的域（如HashMap与Map.Entry）。
 *      如果当多个线程访问一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
 *          1.不在线程之间共享该变量。
 *          2.将状态变量改为不可变。
 *          3.在访问状态变量时使用同步。
 *
 * 2.1 什么是线程安全性
 *      线程安全性核心概念——正确性：某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（PostCondition）来描述对象的操作结果。
 *      当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
 *      示例：程序清单2-1 一个无状态的方法
 *      因此无状态对象一定是线程安全的。
 *
 * 2.2 原子性
 *     我们增加了一个类变量——计数器。方法没被调用一次就加1，如程序清单2-2所示。
 *     ++count看起来很短，但这是一个“读取-修改-写入”的操作序列。并且其结果状态依赖于之前的状态。
 *     竞态条件：由于不恰当的执行时序而出现不正确结果的情况。
 *
 *  2.2.1 竞态条件
 *      当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。
 *      最常见的竞态条件就是“先检查，后执行（Check-Then-Act）”
 *      在程序2-2中就存在竞态条件，再次举例程序2-3也存在同样的问题
 *  2.2.3 复合操作
 *      原子操作：假定有两个操作A和B，从执行A的角度来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B就是原子的。
 *
 *
 *
 */
public class ThreadSafe {

    private Long count = 0L;

    private Object instance = null;

    /**
     *  程序清单2-1 一个无状态的方法
     *  无状态，线程安全的类
     *  这个方法既不包含任何域，也不包含任何对其他域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中。
     */
    public void statelessFactorizer() {
        //do something
        int i = 1;
        i++;
        //do something
    }

    /**
     * 程序清单2-2 在没有同步的情况下计数
     */
    public void unsafeCountingFactorizer() {
        //do something
        ++count;
        System.out.println(count);
    }

    /**
     * 程序清单2-3 延迟初始化的竞态条件
     */
    public Object LazyInitRace() {
        if (instance == null) {
            //do something
            instance = new Object();
            //do something and used 1min
        }
        return instance;
    }

}
